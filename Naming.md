# Рекомендации по именованию

Соблюдение последовательного набора соглашений об именовании при разработке фреймворка может стать серьезным вкладом в его удобство. Это позволяет использовать фреймворк многими разработчиками в совершенно разных проектах. Помимо согласованности формы, имена элементов фреймворка должны быть легко понятны и передавать функцию каждого элемента.

Цель этой главы - предоставить последовательный набор соглашений об именовании, в результате чего имена будут сразу понятны разработчикам.

Принятие этих соглашений об именовании в качестве общих рекомендаций по разработке кода приведет к более последовательному именованию во всем коде. Однако применять их нужно только к тем API, которые открыты для публики (`public` или `protected` типы и члены, а также явно реализованные интерфейсы).

## В этом разделе

[Соглашения о капитализации](#capitalization-conventions)  
[Общие соглашения об именовании](#general-naming-conventions)  
[Имена сборок и DLL](#names-of-assemblies-and-dlls)  
[Имена пространств имен](#names-of-namespaces)  
[Имена классов, структур и интерфейсов](#names-of-classes-structs-and-interfaces)  
[Имена членов типа](#names-of-type-members)  
[Именование параметров](#naming-parameters)  
[Именование ресурсов](#naming-resources)

# <span id="capitalization-conventions">Соглашения о капитализации</span>

В этой главе приведены простые правила использования регистра, которые при последовательном применении делают идентификаторы типов, членов и параметров легко читаемыми.

## Правила написания заглавных букв для идентификаторов

Чтобы различать слова в идентификаторе, пишите первую букву каждого слова в идентификаторе с заглавной буквы. Не используйте подчеркивания для различения слов или, если на то пошло, где-либо в идентификаторах. Существует два способа написания идентификаторов заглавными буквами, в зависимости от их использования:

- PascalCase

- camelCase

Соглашение PascalCase, используемое для всех идентификаторов, за исключением имен параметров, предусматривает выделение заглавными буквами первого символа каждого слова (включая аббревиатуры длиной более двух букв), как показано в следующих примерах:

`PropertyDescriptor`<br/>
`HtmlTag`

Особый случай предусмотрен для двухбуквенных аббревиатур, в которых обе буквы пишутся заглавными, как показано в следующем идентификаторе:

`IOStream`

Соглашение camelCase, используемое только для имен параметров, предусматривает выделение заглавными буквами первого символа каждого слова, кроме первого слова, как показано в следующих примерах. Как видно из примера, двухбуквенные аббревиатуры, с которых начинается идентификатор с camelCase, пишутся в нижнем регистре.

`propertyDescriptor`<br/>
`ioStream`<br/>
`htmlTag`

✔️ ОБЯЗАТЕЛЬНО используйте PascalCase для всех имен открытых членов, типов и пространств имен, состоящих из нескольких слов.

✔️ ОБЯЗАТЕЛЬНО используйте camelCase для имен параметров.

В следующей таблице описаны правила капитализации для различных типов идентификаторов.

|Идентификатор|Нотация|Пример|
|----------------|------------|-------------|
|Namespace|PascalCase|`namespace System.Security { ... }`|
|Type|PascalCase|`public class StreamReader { ... }`|
|Interface|PascalCase|`public interface IEnumerable { ... }`|
|Method|PascalCase|`public class Object {` <br />  `public virtual string ToString();` <br /> `}`|
|Property|PascalCase|`public class String {` <br />  `public int Length { get; }` <br /> `}`|
|Event|PascalCase|`public class Process {` <br />  `public event EventHandler Exited;` <br /> `}`|
|Field|PascalCase|`public class MessageQueue {` <br />  `public static readonly TimeSpan` <br /> `InfiniteTimeout;` <br /> `}` <br /> `public struct UInt32 {` <br />  `public const Min = 0;` <br /> `}`|
|Enum value|PascalCase|`public enum FileMode {` <br />  `Append,` <br />  `...` <br /> `}`|
|Parameter|camelCase|`public class Convert {` <br />  `public static int ToInt32(string value);` <br /> `}`|

## Написание с заглавной буквы сложных слов и общепринятых терминов

Большинство сложных терминов рассматриваются как отдельные слова для целей капитализации.

❌ НЕ пишите с заглавной буквы каждое слово в так называемых закрытых сложных словах.

Это составные слова, которые пишутся как одно слово, например endpoint. В целях соблюдения правил написания заглавных букв рассматривайте закрытое сложное слово как одно слово. Чтобы определить, написано ли сложное слово в закрытой форме, воспользуйтесь актуальным словарем.

|Pascal|Camel|Как не надо|
|------------|-----------|---------|
|`BitFlag`|`bitFlag`|`Bitflag`|
|`Callback`|`callback`|`CallBack`|
|`Canceled`|`canceled`|`Cancelled`|
|`DoNot`|`doNot`|`Don't`|
|`Email`|`email`|`EMail`|
|`Endpoint`|`endpoint`|`EndPoint`|
|`FileName`|`fileName`|`Filename`|
|`Gridline`|`gridline`|`GridLine`|
|`Hashtable`|`hashtable`|`HashTable`|
|`Id`|`id`|`ID`|
|`Indexes`|`indexes`|`Indices`|
|`LogOff`|`logOff`|`LogOut`|
|`LogOn`|`logOn`|`LogIn`|
|`Metadata`|`metadata`|`MetaData, metaData`|
|`Multipanel`|`multipanel`|`MultiPanel`|
|`Multiview`|`multiview`|`MultiView`|
|`Namespace`|`namespace`|`NameSpace`|
|`Ok`|`ok`|`OK`|
|`Pi`|`pi`|`PI`|
|`Placeholder`|`placeholder`|`PlaceHolder`|
|`SignIn`|`signIn`|`SignOn`|
|`SignOut`|`signOut`|`SignOff`|
|`UserName`|`userName`|`Username`|
|`WhiteSpace`|`whiteSpace`|`Whitespace`|
|`Writable`|`writable`|`Writeable`|

## Чувствительность к регистру

Языки, которые могут работать с CLR, не обязаны поддерживать чувствительность к регистру, хотя некоторые из них это делают. Даже если ваш язык поддерживает ее, другие языки, которые могут обращаться к вашему фреймворку, этого не делают. Поэтому любые API, доступные извне, не могут полагаться только на регистр для различения двух имен в одном и том же контексте.

❌ НЕ предполагайте, что все языки программирования чувствительны к регистру. Это не так. Имена не могут различаться только по регистру.

---

# <span id="general-naming-conventions">Общие соглашения об именовании</span>

В этом разделе описаны общие соглашения по именованию, касающиеся выбора слов, рекомендации по использованию сокращений и аббревиатур, а также рекомендации по избежанию использования специфических для данного языка названий.

## Выбор слов

✔️ Выбирайте легко читаемые имена идентификаторов.

Например, свойство с именем `HorizontalAlignment` более удобочитаемо на английском языке, чем `AlignmentHorizontal`.

✔️ Отдавайте предпочтение удобочитаемости перед краткостью.

Имя свойства `CanScrollHorizontally` лучше, чем `ScrollableX` (непонятная ссылка на ось X).

❌ НЕ используйте подчеркивания, дефисы или любые другие не буквенно-цифровые символы.

❌ НЕ используйте венгерскую нотацию.

❌ ЗАПРЕЩАЕТСЯ использовать идентификаторы, которые противоречат ключевым словам широко используемых языков программирования.

Согласно четвёртому правилу Common Language Specification (CLS), все совместимые языки должны предоставлять механизм, позволяющий получать доступ к именованным элементам, использующим ключевое слово этого языка в качестве идентификатора. C#, например, использует знак @ в качестве механизма избегания в этом случае. Однако все же стоит избегать общих ключевых слов, потому что использовать метод с экранирующей последовательностью гораздо сложнее, чем без нее.

## Использование сокращений и аббревиатур

❌ НЕ используйте аббревиатуры или сокращения в именах идентификаторов.

Например, используйте `GetWindow`, а не `GetWin`.

❌ НЕ используйте аббревиатуры, которые не являются общепринятыми, а если и используют, то только в случае необходимости.

## Избегание специфических для языка имен

✔️ Используйте для имен типов семантически интересные имена, а не ключевые слова, специфичные для конкретного языка.

Например, `GetLength` - более удачное название, чем `GetInt`.

✔️ ОБЯЗАТЕЛЬНО используйте общее имя типа CLR, а не имя, специфичное для конкретного языка, в редких случаях, когда идентификатор не имеет семантического значения, выходящего за рамки его типа.

Например, метод, преобразующий в `System.Int64`, должен называться `ToInt64`, а не `ToLong` (потому что `System.Int64` - это CLR-имя для специфического для C# псевдонима `long`). В следующей таблице представлены несколько базовых типов данных, использующих имена типов CLR (а также соответствующие имена типов для C#, Visual Basic и C++).

|C#|Visual Basic|C++|CLR|
|---------|------------------|-----------|---------|
|**sbyte**|**SByte**|**char**|**SByte**|
|**byte**|**Byte**|**unsigned char**|**Byte**|
|**short**|**Short**|**short**|**Int16**|
|**ushort**|**UInt16**|**unsigned short**|**UInt16**|
|**int**|**Integer**|**int**|**Int32**|
|**uint**|**UInt32**|**unsigned int**|**UInt32**|
|**long**|**Long**|**__int64**|**Int64**|
|**ulong**|**UInt64**|**unsigned __int64**|**UInt64**|
|**float**|**Single**|**float**|**Single**|
|**double**|**Double**|**double**|**Double**|
|**bool**|**Boolean**|**bool**|**Boolean**|
|**char**|**Char**|**wchar_t**|**Char**|
|**string**|**String**|**String**|**String**|
|**object**|**Object**|**Object**|**Object**|

✔️ В редких случаях, когда идентификатор не имеет семантического значения и тип параметра не важен, используйте общее имя, например `value` или `item`, а не повторяйте имя типа.

## Именование новых версий существующих API

✔️ При создании новых версий существующих API используйте имя, схожее со старым API.

Это помогает подчеркнуть связь между API.

✔️ Предпочитайте добавление суффикса, а не префикса для обозначения новой версии существующего API.

Это облегчит поиск при просмотре документации или использовании IntelliSense. Старая версия API будет организована рядом с новыми API, поскольку большинство браузеров и IntelliSense отображают идентификаторы в алфавитном порядке.

✔️ Рассматривайте использование совершенно нового, но значимого идентификатора, вместо того чтобы добавлять суффикс или префикс.

✔️ ОБЯЗАТЕЛЬНО используйте числовой суффикс для обозначения новой версии существующего API, особенно если существующее название API - единственное название, которое имеет смысл (т. е. если это промышленный стандарт), и если добавление любого значимого суффикса (или изменение названия) не является подходящим вариантом.

❌ НЕ используйте суффикс "Ex" (или аналогичный) для идентификатора, чтобы отличить его от более ранней версии того же API.

✔️ ОБЯЗАТЕЛЬНО используйте суффикс "64" при представлении версий API, которые работают с 64-битным целым числом (длинным целым числом) вместо 32-битного целого числа. Такой подход нужен только в том случае, если существует 32-битный API; не делайте этого для совершенно новых API, имеющих только 64-битную версию.

---

# <span id="names-of-assemblies-and-dlls">Имена сборок и DLL</span>

Сборка - это единица развертывания и идентификации для программ с управляемым кодом. Хотя сборки могут охватывать один или несколько файлов, обычно сборка сопоставляется с DLL один к одному. Поэтому в этом разделе описаны только соглашения об именовании DLL, которые затем могут быть сопоставлены с соглашениями об именовании сборок.

✔️ ОБЯЗАТЕЛЬНО выбирайте для DLL-сборок имена, которые предполагают наличие больших функциональных блоков, например System.Data.

Имена сборок и DLL не обязательно должны соответствовать именам пространств имен, но при именовании сборок разумно следовать именам пространств имен. Хорошим эмпирическим правилом является именование DLL на основе общего префикса пространств имен, содержащихся в сборке. Например, сборку с двумя пространствами имен, `MyCompany.MyTechnology.FirstFeature` и `MyCompany.MyTechnology.SecondFeature`, можно назвать `MyCompany.MyTechnology.dll`.

✔️ РАЗРЕШАЕТСЯ именовать DLL по следующей схеме:

`<Компания>.<Компонент>.dll`

где `<Компонент>` содержит одно или несколько предложений, разделенных точками. Например:

`Litware.Controls.dll`.

---

# <span id="names-of-namespaces">Имена пространств имен</span>

Как и в случае с другими правилами именования, целью именования пространств имен является создание достаточной ясности для программиста, использующего фреймворк, чтобы он сразу понял, каким будет содержимое пространства имен. Следующий шаблон определяет общее правило для именования пространств имен:

`<Компания>.(<Продукт>|<Технология>)[.<Фича>][.<Подпространство имен>]`.

Ниже приведены примеры:

`Fabrikam.Math`  
`Litware.Security`

✔️ Используйте префикс с названием компании, чтобы пространства имен разных компаний не имели одинаковых имен.

✔️ Используйте стабильное, независимое от версии имя продукта на втором уровне имени пространства имен.

❌ НЕ используйте организационные иерархии в качестве основы для имен в иерархиях пространств имен, поскольку имена групп внутри корпораций, как правило, недолговечны. Организуйте иерархию пространств имен вокруг групп связанных технологий.

✔️ Используйте PascalCase и разделяйте компоненты пространства имен точками (например, `Microsoft.Office.PowerPoint`). Если ваш бренд использует нетрадиционную нотацию, вы должны придерживаться нотацию, определенную вашим брендом, даже если оно отклоняется от обычной нотации пространства имен.

✔️ РАЗРЕШАЕТСЯ использовать имена пространств имен во множественном числе, где это уместно.

Например, используйте `System.Collections` вместо `System.Collection`. Исключением из этого правила являются фирменные наименования и акронимы. Например, используйте `System.IO` вместо `System.IOs`.

❌ НЕ используйте одно и то же имя для пространства имен и типа в этом пространстве имен.

Например, не используйте `Debug` в качестве имени пространства имен, а затем предоставляйте класс с именем `Debug` в том же пространстве имен. Некоторые компиляторы требуют, чтобы такие типы были полностью определены.


### Пространства имен и конфликты имен типов

❌ НЕ вводите общие имена типов, такие как `Element`, `Node`, `Log` и `Message`.

Существует очень высокая вероятность того, что это приведет к конфликтам имен типов в распространенных сценариях. Вам следует квалифицировать общие имена типов (`FormElement`, `XmlNode`, `EventLog`, `SoapMessage`).

Существуют специальные рекомендации по предотвращению конфликтов имен типов для различных категорий пространств имен.

- **Пространства имен модели приложения**.

    Пространства имен, принадлежащие одной модели приложения, очень часто используются вместе, но они почти никогда не используются с пространствами имен других моделей приложений. Например, пространство имен `System.Windows.Forms` очень редко используется вместе с пространством имен `System.Web.UI`. Ниже приведен список известных групп пространств имен моделей приложений:

    `System.Windows*`  
    `System.Web.UI*`

    ❌ НЕ давайте одинаковые имена типам в пространствах имен в рамках одной модели приложения.

    Например, не добавляйте тип с именем `Page` в пространство имен `System.Web.UI.Adapters`, потому что пространство имен `System.Web.UI` уже содержит тип с именем `Page`.

- **Пространства имен инфраструктуры**.

    Эта группа содержит пространства имен, которые редко импортируются при разработке обычных приложений. Например, пространства имен `.Design` в основном используются при разработке инструментов программирования. Избегание конфликтов с типами в этих пространствах имен не является критичным.

- **Основные пространства имен**.

    К основным пространствам имен относятся все пространства имен `System`, за исключением пространств имен моделей приложений и пространств имен Infrastructure. К основным пространствам имен относятся, в частности, `System`, `System.IO`, `System.Xml` и `System.Net`.

    ❌ НЕ давайте типам имена, которые будут конфликтовать с любым типом в пространствах имен Core.

    Например, никогда не используйте `Stream` в качестве имени типа. Это приведет к конфликту с `System.IO.Stream`, очень часто используемым типом.

- **Группы пространств имен технологий**.

    В эту категорию входят все пространства имен с одинаковыми первыми двумя узлами пространства имен `(<Компания>.<Технология>*`), например `Microsoft.Build.Utilities` и `Microsoft.Build.Tasks`. Важно, чтобы типы, принадлежащие к одной технологии, не конфликтовали друг с другом.

    ❌ НЕ назначайте имена типов, которые будут конфликтовать с другими типами в рамках одной технологии.

    ❌ НЕ создавайте конфликтов имен типов между типами в пространствах имен технологий и пространством имен модели приложения (если только технология не предназначена для использования с моделью приложения).

---

# <span id="names-of-classes-structs-and-interfaces">Имена классов, структур и интерфейсов</span>

Следующие рекомендации по именованию относятся к общему именованию типов.

✔️ ОБЯЗАТЕЛЬНО называйте классы и структуры именами существительными или фразами существительных, используя PascalCase.

Это отличает имена типов от имен методов, которые именуются глагольными фразами.

✔️ ОБЯЗАТЕЛЬНО называйте интерфейсы фразами с прилагательными или, иногда, существительными или фразами с существительными.

Существительные и фразы с существительными следует использовать редко, они могут указывать на то, что тип должен быть абстрактным классом, а не интерфейсом.

❌ НЕ давайте именам классов префикс (например, "C").

✔️ РАЗРЕШАЕТСЯ заканчивать имена производных классов именем базового класса.

Это очень удобно для чтения и наглядно объясняет взаимосвязь. В коде это выглядит следующим образом: `ArgumentOutOfRangeException`, который является разновидностью `Exception`, и `SerializableAttribute`, который является разновидностью `Attribute`. Однако при применении этого правила необходимо руководствоваться здравым смыслом; например, класс `Button` является разновидностью события `Control`, хотя `Control` не фигурирует в его имени.

✔️ Префикс имен интерфейсов обозначается буквой I, чтобы указать, что тип является интерфейсом.

Например, `IComponent` (описательное существительное), `ICustomAttributeProvider` (словосочетание с существительным) и `IPersistable` (прилагательное) - подходящие имена интерфейсов. Как и в случае с другими именами типов, избегайте аббревиатур.

✔️ Убедитесь, что имена отличаются только префиксом "I" в имени интерфейса, когда вы определяете пару класс-интерфейс, где класс является стандартной реализацией интерфейса.

## Имена Generic-параметров

Дженерики были добавлены в .NET Framework 2.0. Это позволило ввести новый тип идентификатора, называемый *параметр типа*.

✔️ ОБЯЗАТЕЛЬНО называйте параметры общих типов описательными именами, если только однобуквенное имя не является полностью самоочевидным, а описательное имя не добавит ценности.

✔️ РАЗРЕШАЕТСЯ возможность использования `T` в качестве имени параметра типа для типов с одним однобуквенным параметром типа.

```cs
public int IComparer<T> { ... }
public delegate bool Predicate<T>(T item);
public struct Nullable<T> where T:struct { ... }
```

✔️ ОБЯЗАТЕЛЬНО обозначайте префикс `T` для имен параметров описательного типа.

```csharp
public interface ISessionChannel<TSession> where TSession : ISession {
    TSession Session { get; }
}
```

✔️ ПРЕДУСМОТРИТЕ возможность указывать ограничения, накладываемые на параметр типа, в имени параметра.

Например, параметр с ограничением `ISession` может называться `TSession`.

## Имена общих типов

✔️ При именовании типов, полученных от определенных типов .NET Framework или реализующих их, следуйте рекомендациям, описанным в следующей таблице.

|Базовый тип|Гайдлайн по наследованию/имплементации типа|
|---------------|------------------------------------------|
|`System.Attribute`|✔️ Добавляйте суффикс "Attribute" к именам пользовательских классов атрибутов.|
|`System.Delegate`|✔️ Добавляйте суффикс "EventHandler" к именам делегатов, которые используются в событиях.<br /><br /> ✔️ Добавляйте суффикс "Callback" к именам делегатов, не используемых в качестве обработчиков событий.<br /><br /> ❌ НЕ добавляйте суффикс "Delegate" к делегату.|
|`System.EventArgs`|✔️ Добавляйте суффикс "EventArgs".|
|`System.Enum`|❌ НЕ делайте производных от этого класса; вместо этого используйте ключевое слово, поддерживаемое вашим языком; например, в C# используйте ключевое слово `enum`.<br /><br /> ❌ НЕ добавляйте суффикс "Enum" или "Flag".|
|`System.Exception`|✔️ Добавляйте суффикс "Exception".|
|`IDictionary` <br /> `IDictionary<TKey,TValue>`|✔️ Добавляйте суффикс "Dictionary". Обратите внимание, что `IDictionary` - это особый тип коллекции, но данное руководство имеет приоритет над более общим руководством по коллекциям, которое следует далее.|
|`IEnumerable` <br /> `ICollection` <br /> `IList` <br /> `IEnumerable<T>` <br /> `ICollection<T>` <br /> `IList<T>`|✔️ Добавляйте суффикс "Collection".|
|`System.IO.Stream`|✔️ Добавляйте суффикс "Stream".|
|`CodeAccessPermission IPermission`|✔️ Добавляйте суффикс "Permission".|

## Именование перечислений

Имена типов перечислений (также называемых перечислениями) в целом должны соответствовать стандартным правилам именования типов (PascalCase и т.д.). Однако существуют дополнительные рекомендации, которые относятся именно к перечислениям.

✔️ ОБЯЗАТЕЛЬНО используйте имя типа перечисления в единственном числе, если только его значения не являются битовыми полями.

✔️ Используйте множественное имя типа для перечисления с битовыми полями в качестве значений, также называемого перечислением флагов.

❌ НЕ используйте суффикс "Enum" в именах типов перечислений.

❌ НЕ используйте суффиксы "Flag" или "Flags" в именах типов перечислений.

❌ НЕ используйте префикс в именах значений перечислений (например, "ad" для перечислений ADO, "rtf" для перечислений rich text и т.д.).

---

# <span id="names-of-type-members">Имена членов типа</span>

Типы состоят из членов: методов, свойств, событий, конструкторов и полей. В следующих разделах описаны рекомендации по именованию членов типа.

## Имена методов

Поскольку методы являются средством выполнения действий, руководство по проектированию требует, чтобы имена методов были глаголами или глагольными фразами. Следование этому правилу также позволяет отличить имена методов от имен свойств и типов, которые являются фразами существительных или прилагательных.

✔️ ОБЯЗАТЕЛЬНО давайте методам имена, которые являются глаголами или глагольными фразами.

```csharp
public class String {
    public int CompareTo(...);
    public string[] Split(...);
    public string Trim();
}
```

## Имена свойств

В отличие от других членов, свойствам следует присваивать в имена словосочетания с существительным прилагательное. Это связано с тем, что свойство относится к данным, и имя свойства отражает это. Для имен свойств всегда используется PascalCasing.

✔️ Называйте свойства существительным, словосочетанием с существительным или прилагательным.

❌ НЕ имейте свойств, которые совпадают с именами get-методов, как в следующем примере:

```cs
public string TextWriter { get {...} set {...} }
public string GetTextWriter(int value) { ... }
```

Этот паттерн обычно указывает на то, что свойство на самом деле должно быть методом.

✔️ Называйте свойства коллекции фразой во множественном числе, описывающей элементы коллекции, вместо использования фразы в единственном числе, за которой следует "List" или "Collection".

✔️ Называйте булевы свойства утвердительной фразой (`CanSeek` вместо `CantSeek`). Как вариант, вы также можете добавлять к булевым свойствам префикс "Is", "Can" или "Has", но только в тех случаях, когда это повышает ценность.

✔️ РАЗРЕШАЕТСЯ давать свойству то же имя, что и его типу.

Например, следующее свойство корректно получает и устанавливает значение перечисления с именем `Color`, поэтому свойство называется `Color`:

```csharp
public enum Color {...}
public class Control {
    public Color Color { get {...} set {...} }
}
```

## Имена событий

События всегда относятся к какому-либо действию, либо происходящему, либо произошедшему. Поэтому, как и в случае с методами, события именуются глаголами, а время глагола используется для указания времени, когда событие было вызвано.

✔️ Называйте события с помощью глагола или глагольной фразы.

Примеры: `Clicked`, `Painting`, `DroppedDown` и так далее.

✔️ ОБЯЗАТЕЛЬНО давайте событиям имена с понятием "до" и "после", используя настоящее и прошедшее время.

Например, событие закрытия, которое поднимается до закрытия окна, будет называться `Closing`, а событие, которое поднимается после закрытия окна, будет называться `Closed`.

❌ НЕ используйте префиксы и постфиксы "Before" или "After" для обозначения событий до и после. Используйте настоящее и прошедшее время, как описано выше.

✔️ Называйте обработчики событий (делегаты, используемые в качестве типов событий) с суффиксом "EventHandler", как показано в следующем примере:

```cs
public delegate void ClickedEventHandler(object sender, ClickedEventArgs e);
```

✔️ Используйте в обработчиках событий два параметра с именами `sender` и `e`.

Параметр `sender` представляет объект, вызвавший событие. Параметр отправителя обычно имеет тип `object`, даже если можно использовать более конкретный тип.

✔️ Называйте классы аргументов событий с суффиксом "EventArgs".

## Имена полей

Рекомендации по именованию полей относятся к `public static` и `protected static` полям. На `internal` и `private` поля рекомендации не распространяются, а `public` или `protected` поля экземпляров не допускаются [Руководством по проектированию членов](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/member).

✔️ Используйте PascalCase в именах полей.

✔️ Называйте поля с помощью существительного, словосочетания с существительным или прилагательного.

❌ НЕ используйте префикс для имен полей.

Например, не используйте "g_" или "s_" для обозначения статических полей.

---

# <span id="naming-parameters">Именование параметров</span>

Помимо очевидной причины, связанной с удобством чтения, важно соблюдать рекомендации по наименованию параметров, поскольку параметры отображаются в документации и в дизайнере, когда средства визуального проектирования предоставляют Intellisense и функцию просмотра классов.

✔️ ОБЯЗАТЕЛЬНО используйте camelCase в именах параметров.

✔️ ОБЯЗАТЕЛЬНО используйте описательные имена параметров.

✔️ Рассмотрите возможность использования имён, основанных на значении параметра, а не на его типе.

### Именование параметров перегрузки операторов

✔️ ОБЯЗАТЕЛЬНО используйте `left` и `right` для имен параметров перегрузки бинарных операторов, если у параметров нет смысла.

✔️ ОБЯЗАТЕЛЬНО используйте `value` для имен параметров перегрузки унарных операторов, если они не имеют смысла.

✔️ РАЗРЕШАЕТСЯ использовать осмысленные имена для параметров перегрузки оператора, если это дает значительную ценность.

❌ НЕ используйте аббревиатуры или числовые индексы для имен параметров перегрузки оператора.

---

# <span id="naming-resources">Именование ресурсов</span>

Поскольку на локализуемые ресурсы можно ссылаться через определенные объекты, как если бы они были свойствами, рекомендации по именованию ресурсов аналогичны рекомендациям по именованию свойств.

✔️ ОБЯЗАТЕЛЬНО используйте PascalCase в ключах ресурсов.

✔️ ОБЯЗАТЕЛЬНО используйте описательные, а не короткие идентификаторы.

❌ НЕ используйте ключевые слова языков, специфичных для основных языков CLR.

✔️ В именовании ресурсов используйте только алфавитно-цифровые символы и символы подчеркивания.

✔️ НЕ используйте следующее соглашение об именовании ресурсов сообщений об исключениях.

Идентификатором ресурса должно быть имя типа исключения плюс короткий идентификатор исключения:

`ArgumentExceptionIllegalCharacters`<br/>
`ArgumentExceptionInvalidName`<br/>
`ArgumentExceptionFileNameIsMalformed`
